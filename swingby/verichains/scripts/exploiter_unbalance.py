from typing import List

from Crypto.Util.number import isPrime
from sympy import discrete_log

from _types import Params, Exploiter, Proof
from _util import *


def _search_p_q_h1_h2() -> Tuple[int, int, int, int, int]:
    p = search_prime(1024)
    mask_q = (0b11 << (2048 - 1024 - 2)) | 0b11
    while True:
        # gen N = p*q
        q = 0
        while not isPrime(q):
            q = random.getrandbits(2048 - 1024) | mask_q
        N = p * q
        h2 = N - 1
        t = 1337
        alpha0 = pow(h2, t, N)
        alpha1 = compute_x_x(alpha0, 2048 + 8)
        h1 = alpha0 * pow(alpha1, -1, N)
        return p, q, h1, h2, t


def forge_proof(N: int, h1: int, h2: int, t: int, repeat: int) -> Proof:
    """Build proofs for discrete logs between h1 and h2 under certain preconditions."""
    alpha0 = pow(h2, t, N)
    alpha1 = compute_x_x(alpha0, 2048 + 8)
    assert alpha0 == alpha1 * h1 % N

    # forging proof of dlog(h1, base=h2)
    while alpha0.bit_length() <= 2048:
        alpha0 += N
    alpha1 = compute_x_x(alpha0)
    found = False
    challenge = 0
    while not found:
        for c1 in range(max(repeat // 2 - 16, 0), min(repeat // 2 + 16, repeat + 1)):
            c0 = repeat - c1
            challenge = hash_ints([h1, h2, N] + [alpha0] * c0 + [alpha1] * c1) % 2 ** repeat
            if challenge.bit_count() == c1:
                found = True
                break
        if found:
            break

        alpha0 += N
        assert alpha0.bit_length() <= 2048 + 8
        alpha1 = compute_x_x(alpha0)

    return Proof(
        A=[alpha1 if challenge >> i & 1 else alpha0 for i in range(repeat)],
        Z=[t] * repeat
    )


class UnbalanceExploiter(Exploiter):
    """Exploit using N = p*q, p is 260 bit."""

    def __init__(self, dlog_proof_repeat: int):
        p, q, h1, h2, t = _search_p_q_h1_h2()
        N = p * q
        proof = forge_proof(N, h1, h2, t, dlog_proof_repeat)
        self._params = Params(N, p, q, h1, h2, proof)
        self._p = p
        self._g = pow(h1, 2, p)

    def params(self) -> Params:
        return self._params

    def recover_shares(self, self_x: int, self_share: int, xz: List[Tuple[int, int]]) -> Tuple[List[int], int]:
        set_x = {xi for xi, _ in xz}
        set_x.add(self_x)
        coeffs = {xi: eq_x_xi(SECP256K1_Q, set_x, 0, xi) for xi in set_x}

        p = self._p
        g = self._g

        w = []
        for _, zi in xz:
            wi = discrete_log(p, pow(zi, 2, p), g)
            w.append(int(wi))

        secret_key = (sum(w) + coeffs[self_x] * self_share) % SECP256K1_Q
        return [wi * pow(coeffs[xi], -1, SECP256K1_Q) % SECP256K1_Q for (xi, _), wi in zip(xz, w)], secret_key

    def recover_nonce(self, self_k: int, z: List[int]) -> int:
        p = self._p
        g = self._g
        nonce = self_k
        for zi in z:
            ki = discrete_log(p, pow(zi, 2, p), g)
            nonce = (nonce + int(ki)) % SECP256K1_Q
        return pow(nonce, -1, SECP256K1_Q)
