import logging
from dataclasses import dataclass, field
from typing import Dict, List

from aiohttp import web
from sage.all import GF, product, matrix, vector


@dataclass
class SigningData:
    m: int = 0
    r: int = 0
    s: int = 0
    delta: int = 0
    w_i: int = 0
    h1_pow_w_j: List[int] = field(default_factory=list)
    gamma_i: int = 0
    h1_pow_gamma_j: List[int] = field(default_factory=list)


@dataclass
class SigningSession:
    pkx: int
    i: int
    data: SigningData


sessions: Dict[str, SigningSession] = {}


def save_sessions():
    with open('data', 'w') as f:
        f.write(repr(sessions))


def load_sessions():
    global sessions
    with open('data', 'r') as f:
        sessions = eval(f.read())


async def handle_create_session(request: web.Request) -> web.Response:
    obj = await request.json()
    if any(field not in obj for field in ("sess_id", "pkx", "i")):
        raise web.HTTPBadRequest
    sessions[obj['sess_id']] = SigningSession(
        pkx=int(obj["pkx"]),
        i=int(obj["i"]),
        data=SigningData()
    )
    return web.Response()


async def handle_submit_signing_data(request: web.Request) -> web.Response:
    obj = await request.json()
    if any(field not in obj for field in ("sess_id",)):
        raise web.HTTPBadRequest
    id = obj['sess_id']
    if id not in sessions:
        raise web.HTTPNotFound
    data = sessions[id].data
    for k, v in obj.items():
        try:
            v = int(v)
        except ValueError:
            pass
        if k == 'sess_id':
            continue
        if k == "m":
            data.m = v
        elif k == "r":
            data.r = v
        elif k == "s":
            data.s = v
        elif k == "delta":
            data.delta = v
        elif k == "w_i":
            data.w_i = v
        elif k == "gamma_i":
            data.gamma_i = v
        elif k == "h1_pow_w_j":
            data.h1_pow_w_j.append(v)
        elif k == "h1_pow_gamma_j":
            data.h1_pow_gamma_j.append(v)
        else:
            print("Bad field:", k)
            raise web.HTTPBadRequest
    save_sessions()
    return web.Response()


async def handle_recover_private_key(request: web.Request) -> web.Response:
    obj = await request.json()
    if any(field not in obj for field in ("pkx", "i")):
        raise web.HTTPBadRequest
    data = []
    for s in sessions.values():
        if (s.pkx, s.i) == (int(obj["pkx"]), int(obj["i"])):
            data.append(s.data)
    if not data:
        raise web.HTTPNotFound

    print(recover_private_key(obj["pkx"], data))
    return web.Response()


PARAMS = {
    "p": 57503,
    "h1": 1337,
}
SECP256K1_Q = 115792089237316195423570985008687907852837564279074904382605163141518161494337
Fq = GF(SECP256K1_Q)


def recover_private_key(pkx: int, data: List[SigningData]) -> int:
    p = PARAMS["p"]
    Fp = GF(p)
    h1 = Fp(PARAMS["h1"])
    n = len(data)
    M = [[0] * (n+1) for _ in range(n+1)]
    vec = [0] * (n + 1)
    w_r = 0
    for i, sd in enumerate(data):
        m, r, s, delta = sd.m, sd.r, sd.s, sd.delta
        if w_r == 0:
            w_r = (sd.w_i + product(Fp(x) for x in sd.h1_pow_w_j).log(h1)) % (p - 1)
        else:
            assert w_r == (sd.w_i + product(Fp(x) for x in sd.h1_pow_w_j).log(h1)) % (p - 1)
        gamma_r = (sd.gamma_i + product(Fp(x) for x in sd.h1_pow_gamma_j).log(h1)) % (p - 1)
        A = (Fq(delta) * r * (p - 1)) / (Fq(s) * (p - 1))
        B = -(Fq(delta) * (m + r * w_r) - s * gamma_r) / (Fq(s) * (p - 1))
        M[i][0] = int(A)
        M[i][1 + i] = SECP256K1_Q
        vec[i] = int(B)
    M[n][0] = 1
    vec[n] = 0
    M_ = matrix(M).transpose().LLL()
    tmp = M_.solve_left(vector(vec))
    tmp = vector(map(round, tmp))
    return int((tmp * M_)[n]) * (p - 1) + w_r


if __name__ == '__main__':
    try:
        load_sessions()
    except Exception as e:
        print(e)
        pass
    logging.basicConfig(level=logging.INFO)
    app = web.Application()
    app.add_routes([web.post('/create-session', handle_create_session)])
    app.add_routes([web.post('/submit-signing-data', handle_submit_signing_data)])
    app.add_routes([web.post('/recover-private-key', handle_recover_private_key)])
    web.run_app(app, port=1337)
