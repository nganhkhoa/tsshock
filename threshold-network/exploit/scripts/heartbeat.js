const hre = require("hardhat");
const fs = require('fs');
function delay(time) {
    return new Promise(resolve => setTimeout(resolve, time));
  } 

  function delay(time) {
    return new Promise(resolve => setTimeout(resolve, time));
  } 
  

async function main() {
  console.log("#################################\n");
  console.log("Request new heartbeat and extract private key\n")
  console.log("#################################\n");

    fs.rmSync('/tmp/privatekey.txt',{force:true});
    const mainAddress = fs.readFileSync("/tmp/main.txt", 'utf8');
    const walletHash = fs.readFileSync("/tmp/wallet.txt", 'utf8');
    const wallet = walletHash.split("|");

    console.log("Try recover private key for wallet (%s)\n",wallet[1]);
    const main = await hre.ethers.getContractAt("Main", mainAddress);
    await (await main.heartbeat(wallet[0])).wait();

    while(!fs.existsSync('/tmp/privatekey.txt')){
      delay(5000);
    }
    const privatekey = fs.readFileSync("/tmp/privatekey.txt", 'utf8');
   
    var signing = new hre.ethers.utils.SigningKey( JSON.parse(privatekey).private_key )

    console.log("Successfully recover privatekey:"+signing.privateKey+"\n");
    console.log("Verify privatekey with wallet: %s\n",signing.publicKey==wallet[1]?"TRUE":"FALSE");
    

}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
console.error(error);
process.exitCode = 1;
});