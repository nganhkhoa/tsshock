const hre = require("hardhat");
const fs = require('fs');

async function deployWalletRegistry(main){
  const randomBaconAddress = await main.randomBacon();
  const reimbursementPoolAddress = await main.reimbursementPool();
  const stakingAddress = await main.staking();
  const sortitionPoolAddress = await main.sortitionPool();

  const EcdsaInactivity = await hre.ethers.getContractFactory("EcdsaInactivity");
  const ecdsaInactivity = await EcdsaInactivity.deploy();
  await ecdsaInactivity.deployed();

  const validator = "LightDkgValidator";
  //const validator = "EcdsaDkgValidator";

  const EcdsaDkgValidator = await ethers.getContractFactory(validator);
  const ecdsaDkgValidator = await EcdsaDkgValidator.deploy(sortitionPoolAddress);
  await ecdsaDkgValidator.deployed();


  const WalletRegistry = await hre.ethers.getContractFactory("WalletRegistry",{
    libraries: {
      EcdsaInactivity: ecdsaInactivity.address,
    },
  });
  const walletRegistry = await upgrades.deployProxy(WalletRegistry, [ecdsaDkgValidator.address,randomBaconAddress,reimbursementPoolAddress], {
    constructorArgs: [sortitionPoolAddress, stakingAddress],
    unsafeAllow: ["external-library-linking"],
    kind: "transparent",
  });
 
  await walletRegistry.deployed();

  await (await walletRegistry.updateWalletOwner(main.address)).wait();
  await (await main.setWalletRegistry(walletRegistry.address)).wait();

}

async function writeConfig(main){
  randomBaconAddress = await main.randomBacon()
  bridgeAddress = await main.bridge();
  stakingAddress = await main.staking();
  walletRegistryAddress = await main.walletRegistry();
  walletCoordinatorAddress = await main.walletCoordinator();



  var data = fs.readFileSync("./config.tmpl.toml", 'utf8');
   
  data = data.replace(/<TokenStakingAddress>/g, stakingAddress);
  data = data.replace(/<BridgeAddress>/g, bridgeAddress);
  data = data.replace(/<WalletCoordinatorAddress>/g, walletCoordinatorAddress);
  data = data.replace(/<RandomBeaconAddress>/g, randomBaconAddress);
  data = data.replace(/<WalletRegistryAddress>/g, walletRegistryAddress);

  //honest config
  data2 = data;
  data2 = data2.replace(/<KeyFile>/g, "./keystore/honest");
  data2 = data2.replace(/<Port>/g, "7070");
  data2 = data2.replace(/<Peer>/g, "/ip4/127.0.0.1/tcp/7071/ipfs/16Uiu2HAmMUjGmiUhJeiZgu6ZZnLRkE2VViR2JgjqtW9aTZnHQqgg");
  data2 = data2.replace(/<StorageDir>/g, "./data/honest");
  fs.writeFileSync("./config.honest.toml", data2, 'utf8');

  //malicous config
  data2 = data;
  data2 = data2.replace(/<KeyFile>/g, "./keystore/malicious");
  data2 = data2.replace(/<Port>/g, "7071");
  data2 = data2.replace(/<Peer>/g, "/ip4/127.0.0.1/tcp/7070/ipfs/16Uiu2HAm7y4wLLNsMjdvS9dKgbXmmmDr8TaiL2HWZrd6sRFZqGZM");
  data2 = data2.replace(/<StorageDir>/g, "./data/malicious");
  fs.writeFileSync("./config.malicious.toml", data2, 'utf8');
 
}

async function main() {
  console.log("#################################\n");
  console.log("Deploy smartcontracts and generate config.toml\n")
  console.log("#################################\n");
  const honest = "0x70997970c51812dc3a010c7d01b50e0d17dc79c8";
  const malicious = "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266";
  
  let main;
  const Main = await hre.ethers.getContractFactory("Main");

    main = await Main.deploy(malicious, honest);
    await main.deployed();
    fs.writeFileSync("/tmp/main.txt", main.address, 'utf8');

  await deployWalletRegistry(main);
  await writeConfig(main);
  

}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});