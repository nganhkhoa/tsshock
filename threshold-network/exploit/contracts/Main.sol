// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;
import "@keep-network/ecdsa/contracts/WalletRegistry.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@keep-network/random-beacon/contracts/libraries/BytesLib.sol";



contract MockSortitionPool {
    bool public isLocked;
    address public maliciousOp ;
    address public honestOp ;

    constructor(address _maliciousOp, address _honestOp){
        maliciousOp = _maliciousOp;
        honestOp = _honestOp;
    }
    function isOperatorInPool(address operator) public view returns (bool) {
        return true;
    }

    function isOperatorUpToDate(address operator, uint256 authorizedStake) public view returns (bool)
    {
        return true;
    }

     function isEligibleForRewards(address operator) public view returns (bool) {
        return true;
        }


    function lock() public {
    isLocked = true;
  }

  /// @notice Unlocks the sortition pool. Removes all restrictions set by
  ///         the `lock` method.
  /// @dev Can be called only by the contract owner.
  function unlock() public  {
    isLocked = false;
  }

    function selectGroup(uint256 groupSize, bytes32 seed)
    public
    view
    returns (uint32[] memory)
  {
    uint quorum = 5;
    uint32[] memory selected = new uint32[](5);

    for (uint256 i = 0; i < quorum; i++) {
      selected[i] = i == 0 ? 0 : 1;
    }
    return selected;
  }
    function getIDOperators(uint32[] calldata ids)
    public
    view
    returns (address[] memory)
  {
   
    

    address[] memory operators = new address[](ids.length);
    for (uint256 i = 0; i < ids.length; i++) {
      operators[i] = i == 0 ? maliciousOp : honestOp;
    }
    return operators;
  }

  function getIDOperator(uint32 i) public returns (address ) {
    return i == 0 ? maliciousOp : honestOp;
    }

  function getOperatorID(address a) public returns (uint32){
    return a == maliciousOp? 0:1; 
  } 

}

contract MockStaking {
 function authorizedStake(address stakingProvider, address application)
        external
        view
        returns (uint96){
            return 400_000e18;
        }
}

interface IMockRandomBaconConsumer {
     function __beaconCallback(uint256 relayEntry, uint256) external;
}


contract MockRandomBacon {
    MockSortitionPool public sortitionPool;
    IStaking public  staking;
    uint nonce = 0;
    IMockRandomBaconConsumer public callback;

    constructor(MockSortitionPool sp, IStaking st){
        sortitionPool = sp;
        staking = st;
    }

    function requestRelayEntry(address callbackContract) external{
        callback = IMockRandomBaconConsumer(callbackContract);
        
    }

    function invokeRelay() external {
        callback.__beaconCallback(1336, 0x0);
    }


    function operatorToStakingProvider(address operator)external returns (address) {
        return address(staking);
    }
}

contract Bank {

}

contract Relay {

}



contract WalletCoordinator {
     enum WalletAction {
        /// @dev The wallet does not perform any action.
        Idle,
        /// @dev The wallet is executing heartbeat.
        Heartbeat,
        /// @dev The wallet is handling a deposit sweep action.
        DepositSweep,
        /// @dev The wallet is handling a redemption action.
        Redemption,
        /// @dev The wallet is handling a moving funds action.
        MovingFunds,
        /// @dev The wallet is handling a moved funds sweep action.
        MovedFundsSweep
    }

    /// @notice Holds information about a wallet time lock.
    struct WalletLock {
        /// @notice A UNIX timestamp defining the moment until which the wallet
        ///         is locked and cannot receive new proposals. The value of 0
        ///         means the wallet is not locked and can receive a proposal
        ///         at any time.
        uint32 expiresAt;
        /// @notice The wallet action being the cause of the lock.
        WalletAction cause;
    }

     mapping(bytes20 => WalletLock) public walletLock;

     event HeartbeatRequestSubmitted(
        bytes20 walletPubKeyHash,
        bytes message,
        address indexed coordinator
    );
    
    function requestHeartbeat(bytes20 walletPubKeyHash, bytes calldata message)
        public
       
    {
       

        walletLock[walletPubKeyHash] = WalletLock(
            /* solhint-disable-next-line not-rely-on-time */
            uint32(block.timestamp) + 1 hours,
            WalletAction.Heartbeat
        );

        emit HeartbeatRequestSubmitted(walletPubKeyHash, message, msg.sender);
    }


}

interface IWalletRegistry2 {
    function registerOperator(address) external; 
    function updateWalletOwner(IWalletOwner) external;
    function requestNewWallet() external;
}

contract StakingProvider {
    function registerOperator(IWalletRegistry2 reg, address op) external{
        reg.registerOperator(op);
    }
}

contract Bridge {
    Bank _bank;
    Relay _relay;
    IWalletRegistry2 _ecdsaWalletRegistry;
    ReimbursementPool _reimbursementPool;
    constructor( Bank bank,Relay relay,IWalletRegistry2 ecdsaWalletRegistry,ReimbursementPool reimbursementPool){
        _bank = bank;
        _relay = relay;
        _ecdsaWalletRegistry = ecdsaWalletRegistry;
        _reimbursementPool = reimbursementPool;
    }

    function contractReferences()
        external
        view
        returns (
            Bank bank,
            Relay relay,
            IWalletRegistry2 ecdsaWalletRegistry,
            ReimbursementPool reimbursementPool
        )
    {
        return (_bank, _relay, _ecdsaWalletRegistry, _reimbursementPool);
       
    }
}


contract Main is IWalletOwner {
    MockRandomBacon public randomBacon;
    Bridge public bridge;
    IStaking public staking;
    IWalletRegistry2 public walletRegistry;
    WalletCoordinator public walletCoordinator;
    MockSortitionPool public sortitionPool;
    ReimbursementPool public reimbursementPool;

    bytes32 public walletID;
    uint  m = 0xffffffffffffffffffffffffff000000;

    constructor(address maliciousOp, address honestOp){
        sortitionPool = new MockSortitionPool(maliciousOp, honestOp);
        staking = IStaking(address(new MockStaking()));
        randomBacon = new  MockRandomBacon(sortitionPool, staking);
        walletCoordinator = new WalletCoordinator();
        reimbursementPool = new ReimbursementPool(0,0);
    }

    function setWalletRegistry(address wr) external{
        walletRegistry = IWalletRegistry2(wr);
        Bank bank = new Bank();
        Relay relay = new Relay();
        
        bridge = new Bridge( bank, relay, walletRegistry, reimbursementPool);
        new StakingProvider().registerOperator(walletRegistry, sortitionPool.maliciousOp());
        new StakingProvider().registerOperator(walletRegistry, sortitionPool.honestOp());
    }

    function invokeWallet() external {
        walletRegistry.requestNewWallet();
    }

    function invokeRelay() external {
        randomBacon.invokeRelay();
    }

    function heartbeat(bytes20 walletPubKeyHash) external {
        m = m+1;

         walletCoordinator.requestHeartbeat(walletPubKeyHash, abi.encodePacked(m));
    }

     function __ecdsaWalletCreatedCallback(
        bytes32 _walletID,
        bytes32 publicKeyX,
        bytes32 publicKeyY
    ) external{
      walletID = _walletID;
    }

    
    function __ecdsaWalletHeartbeatFailedCallback(
        bytes32 _walletID,
        bytes32 publicKeyX,
        bytes32 publicKeyY
    ) external{

    }

}