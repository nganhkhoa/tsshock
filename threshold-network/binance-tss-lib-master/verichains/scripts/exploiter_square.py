from typing import List
from Crypto.Util.number import isPrime
from _types import Proof, Params, Exploiter
from _util import *


def _search_p_h1_h2() -> Tuple[int, int, int, int, int]:
    """
    Search for p, h1, h2, exp, t such that:
        - p*(p-1)/order(h2) > 2**256
        - h2**t/h1 = compute_x_x(h2**t) (for forging proof of dlog(h1, base=h2))
        - h2 == h1**exp mod p**2
    """
    mask_p = (0b11 << 1022) | 1
    while True:
        # gen p
        p = 0
        while not isPrime(p):
            p = random.getrandbits(1024) | mask_p
        N = p ** 2
        phi_N = p * (p - 1)

        # choose h2, exp, t
        h2 = N - 1  # order(h2) = 2
        exp = phi_N // 2
        t = 3

        # compute h1
        alpha0 = h2  # pow(h2, t, N) == h2 == N - 1
        alpha1 = compute_x_x(alpha0, 2048 + 8)
        h1 = alpha0 * pow(alpha1, -1, N) % N
        if pow(h1, exp, N) == h2:
            return p, h1, h2, exp, t


def build_proofs(N: int, h1: int, h2: int, exp: int, t: int, repeat: int) -> Tuple[Proof, Proof]:
    """Build proofs for discrete logs between h1 and h2 under certain preconditions."""
    assert pow(h1, exp, N) == h2
    alpha0 = pow(h2, t, N)
    alpha1 = compute_x_x(alpha0, 2048 + 8)
    assert alpha0 == alpha1 * h1 % N

    # forging proof of dlog(h1, base=h2)
    while alpha0.bit_length() <= 2048:
        alpha0 += N
    alpha1 = compute_x_x(alpha0)
    found = False
    challenge = 0
    while not found:
        for c1 in range(max(repeat // 2 - 16, 0), min(repeat // 2 + 16, repeat + 1)):
            c0 = repeat - c1
            challenge = hash_ints([h2, h1, N] + [alpha0] * c0 + [alpha1] * c1) % 2 ** repeat
            if challenge.bit_count() == c1:
                found = True
                break
        if found:
            break

        alpha0 += N
        assert alpha0.bit_length() <= 2048 + 8
        alpha1 = compute_x_x(alpha0)

    proof_dlog_h1_base_h2 = Proof(
        alpha=[alpha1 if challenge >> i & 1 else alpha0 for i in range(repeat)],
        t=[t] * repeat
    )

    # building proof of dlog(h2, base=h1)
    assert pow(h1, exp, N) == h2
    alpha = pow(h1, 1337, N)
    challenge = hash_ints([h1, h2, N] + [alpha] * repeat) % 2 ** repeat
    proof_dlog_h2_base_h1 = Proof(
        alpha=[alpha] * repeat,
        t=[1337 + (exp if challenge >> i & 1 else 0) for i in range(repeat)]
    )

    return proof_dlog_h2_base_h1, proof_dlog_h1_base_h2


class SquareExploiter(Exploiter):
    """Exploit using N = p**2 technique."""

    def __init__(self, dlog_proof_repeat: int):
        p, h1, h2, exp, t = _search_p_h1_h2()
        N = p ** 2
        proof_dlog_h2_base_h1, proof_dlog_h1_base_h2 = build_proofs(N, h1, h2, exp, t, dlog_proof_repeat)
        self._params = Params(N, p, 1, h1, h2, proof_dlog_h2_base_h1, proof_dlog_h1_base_h2)
        self._p = p
        k = pow(h1, p - 1, N)
        k = (k - 1) // p
        self._inv_k = pow(k, -1, p)

    def params(self) -> Params:
        return self._params

    def recover_shares(self, self_x: int, self_share: int, xz: List[Tuple[int, int]]) -> Tuple[List[int], int]:
        set_x = {xi for xi, _ in xz}
        set_x.add(self_x)
        coeffs = {xi: eq_x_xi(SECP256K1_Q, set_x, 0, xi) for xi in set_x}

        p = self._p
        N = p ** 2
        inv_k = self._inv_k

        w = []
        for _, zi in xz:
            wi = pow(zi, p - 1, N)
            wi = (wi - 1) // p
            wi = wi * inv_k % p
            w.append(wi)

        secret_key = (sum(w) + coeffs[self_x] * self_share) % SECP256K1_Q
        return [wi * pow(coeffs[xi], -1, SECP256K1_Q) % SECP256K1_Q for (xi, _), wi in zip(xz, w)], secret_key

    def recover_nonce(self, self_k: int, z: List[int]) -> int:
        raise "unimplemented"
