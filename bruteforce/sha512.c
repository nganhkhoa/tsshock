#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#region https://github.com/LeFroid/sha256-512
typedef struct PaddedMsg {
  size_t length;
  uint8_t msg[2048];
} PaddedMsg;

// Swaps the byte order of the 32 bit unsigned integer x
inline void endianSwap32(uint32_t *x)
{
    char *y = (char*)x;
    for (size_t low = 0, high = sizeof(uint32_t) - 1; high > low; ++low, --high)
    {
        y[low]  ^= y[high];
        y[high] ^= y[low];
        y[low]  ^= y[high];
    }
}

// Swaps the byte order of the 64 bit unsigned integer x
inline void endianSwap64(uint64_t *x)
{
    char *y = (char*)x;
    for (size_t low = 0, high = sizeof(uint64_t) - 1; high > low; ++low, --high)
    {
        y[low]  ^= y[high];
        y[high] ^= y[low];
        y[low]  ^= y[high];
    }
}

// Swaps the byte order of the 128 bit unsigned integer x
inline void endianSwap128(__uint128_t *x)
{
    char *y = (char*)x;
    for (size_t low = 0, high = sizeof(__uint128_t) - 1; high > low; ++low, --high)
    {
        y[low]  ^= y[high];
        y[high] ^= y[low];
        y[low]  ^= y[high];
    }
}

const int SHA512_MESSAGE_BLOCK_SIZE = 128;
// const int SHA512_HASH_SIZE = 64;
const int HASH_ARRAY_LEN = 8;
const int HASH_RESULT_ARRAY_LEN = 4;
// const unsigned long long MAX_VAL = 0xFFFFFFFFFFFFFFFFLLU;

// K: first 64 bits of the fractional parts of the cube roots of the first 80 primes
const static uint64_t K[80] =
{
    0x428A2F98D728AE22, 0x7137449123EF65CD, 0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC,
    0x3956C25BF348B538, 0x59F111F1B605D019, 0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118,
    0xD807AA98A3030242, 0x12835B0145706FBE, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
    0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x9BDC06A725C71235, 0xC19BF174CF692694,
    0xE49B69C19EF14AD2, 0xEFBE4786384F25E3, 0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65,
    0x2DE92C6F592B0275, 0x4A7484AA6EA6E483, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
    0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0xB00327C898FB213F, 0xBF597FC7BEEF0EE4,
    0xC6E00BF33DA88FC2, 0xD5A79147930AA725, 0x06CA6351E003826F, 0x142929670A0E6E70,
    0x27B70A8546D22FFC, 0x2E1B21385C26C926, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
    0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x81C2C92E47EDAEE6, 0x92722C851482353B,
    0xA2BFE8A14CF10364, 0xA81A664BBC423001, 0xC24B8B70D0F89791, 0xC76C51A30654BE30,
    0xD192E819D6EF5218, 0xD69906245565A910, 0xF40E35855771202A, 0x106AA07032BBD1B8,
    0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8,
    0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB, 0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3,
    0x748F82EE5DEFB2FC, 0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
    0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0xBEF9A3F7B2C67915, 0xC67178F2E372532B,
    0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178,
    0x06F067AA72176FBA, 0x0A637DC5A2C898A6, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
    0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C,
    0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A, 0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817
 };

// Utility functions
// Rotate x to the right by numBits
#define ROTR(x, numBits) ( (x >> numBits) | (x << (64 - numBits)) )

// Compression functions
#define Ch(x,y,z) ( (x & y) ^ ((~x) & z) )
#define Maj(x,y,z) ( (x & y) ^ (x & z) ^ (y & z) )

#define BigSigma0(x) ( ROTR(x,28) ^ ROTR(x,34) ^ ROTR(x,39) )
#define BigSigma1(x) ( ROTR(x,14) ^ ROTR(x,18) ^ ROTR(x,41) )

#define SmallSigma0(x) ( ROTR(x,1) ^ ROTR(x,8) ^ (x >> 7) )
#define SmallSigma1(x) ( ROTR(x,19) ^ ROTR(x,61) ^ (x >> 6) )

// SHA512 message schedule
// Calculate the Nth block of W
void W(uint64_t* w, int N, uint64_t *M)
{
    uint64_t *mPtr = &M[(N * 16)];

    //printf("Message block %d : ", N);
    for (int i = 0; i < 16; ++i)
    {
        w[i] = *mPtr;
        ++mPtr;

    //printf("%" PRIx64 , w[i]);
    }
    //printf("\n");
    for (int i = 16; i < 80; ++i)
    {
        w[i] = SmallSigma1(w[i - 2]) + w[i - 7] + SmallSigma0(w[i - 15]) + w[i - 16];
    }
}

// Step 1:
// Preprocesses a given message of l bits.
// Appends "1" to end of msg, then k 0 bits such that l + 1 + k = 896 mod 1024
// and k is the smallest nonnegative solution to said equation. To this is appended
// the 128 bit block equal to the bit length l.
//char *preprocess(char *msg)
void preprocess(PaddedMsg& padded, const uint8_t *msg, size_t len, size_t original_len)
{
    // resulting msg wll be multiple of 1024 bits
    //size_t len = strlen(msg);
    if (msg == NULL || len == 0)
    {
        padded.length = 0;
        return;
    }

    size_t l = len * 8;
    size_t k = (896 - ( (original_len*8  + 1) % 1024 )) % 1024;
    // printf("k = %zu\n", k);
    // printf("l = %zu\n", l);
    // printf("l + k + 1 = %zu bits, %zu bytes\n", (l+k+1), ((l+k+1)/8));

    padded.length = ((l + k + 1) / 8) + 16;
    //printf("padded.length = %zu\n", padded.length);
    // padded.msg = (uint8_t*) malloc(sizeof(uint8_t) * padded.length);
    memset(&padded.msg[0], 0, sizeof(padded.msg));
    for (size_t i = 0; i < len; ++i)
        padded.msg[i] = msg[i];
    // append to the binary string a 1 followed by k zeros
    padded.msg[len] = 0x80;

    // last 16 bytes reserved for length
    __uint128_t bigL = original_len*8;
    endianSwap128(&bigL);
    memcpy(&padded.msg[padded.length - sizeof(__uint128_t)], &bigL, sizeof(__uint128_t));
}

// Step 2:
// Parse the padded message into N 1024-bit blocks
// Each block separated into 64-bit words (therefore 16 per block)
// Returns an array of 8 64 bit words corresponding to the hashed value
uint64_t *getHash(uint64_t *retVal, PaddedMsg *p)
{
    size_t N = p->length / SHA512_MESSAGE_BLOCK_SIZE;
    //printf("Number of blocks = %zu\n", N);

    // initial hash value
    // uint64_t h[8] = {
    //     0x6A09E667F3BCC908,
    //     0xBB67AE8584CAA73B,
    //     0x3C6EF372FE94F82B,
    //     0xA54FF53A5F1D36F1,
    //     0x510E527FADE682D1,
    //     0x9B05688C2B3E6C1F,
    //     0x1F83D9ABFB41BD6B,
    //     0x5BE0CD19137E2179
    // };

    // uint64_t h[8] = {
    //     0x22312194FC2BF72C,
    //     0x9F555FA3C84C64C2,
    //     0x2393B86B6F53B151,
    //     0x963877195940EABD,
    //     0x96283EE2A88EFFE3,
    //     0xBE5E1E2553863992,
    //     0x2B0199FC2C85B8AA,
    //     0x0EB72DDC81C52CA2
    // };


    // start of round 4
    uint64_t h[8] = {
        0x3c4215ffb335eec9,
        0x3661b34283d95946,
        0xec547cf905e9143d,
        0x1de189b9f94abb5f,
        0x4131ecd40ef66b7d,
        0xc76285fcbadbeb82,
        0xffe30063f0a91944,
        0x19736f2d66f93554,
    };

#if MACHINE_BYTE_ORDER == LITTLE_ENDIAN
    // Convert byte order of message to big endian
    uint64_t *msg = ((uint64_t*)&p->msg[0]);
    for (int i = 0; i < N * 16; ++i)
        endianSwap64(msg++);
#endif

    uint64_t w[80];
    uint64_t reg[HASH_ARRAY_LEN];
    for (size_t i = 0; i < N; ++i)
    {
        uint64_t T1, T2;
        // initialize registers
        #pragma unroll
        for (int i2 = 0; i2 < HASH_ARRAY_LEN; ++i2)
            reg[i2] = h[i2];

        W(w, i, ((uint64_t*)(p->msg)));

        // Apply the SHA512 compression function to update registers
        #pragma unroll
        for (int j = 0; j < 80; ++j)
        {
            T1 = reg[7] + BigSigma1(reg[4]) + Ch(reg[4], reg[5], reg[6]) + K[j] + w[j];
            T2 = BigSigma0(reg[0]) + Maj(reg[0], reg[1], reg[2]);

            reg[7] = reg[6];
            reg[6] = reg[5];
            reg[5] = reg[4];
            reg[4] = reg[3] + T1;
            reg[3] = reg[2];
            reg[2] = reg[1];
            reg[1] = reg[0];
            reg[0] = T1 + T2;
        }

        // Compute the ith intermediate hash values
        #pragma unroll
        for (int i = 0; i < HASH_ARRAY_LEN; ++i)
            h[i] += reg[i];

        printf("// start of round %llu\n", i + 1);
        printf("uint64_t h[8] = {\n");
        #pragma unroll
        for (int i = 0; i < HASH_ARRAY_LEN; ++i)
            printf("    0x%016llx,\n", h[i]);
        printf("};\n");
    }
    // Now the array h is the hash of the original message M
    memcpy(retVal, h, sizeof(uint64_t) * HASH_RESULT_ARRAY_LEN);
    #if MACHINE_BYTE_ORDER == LITTLE_ENDIAN
        // Convert byte order of message to big endian
        uint64_t *retValPtr = retVal;
        #pragma unroll
        for (int i = 0; i < HASH_RESULT_ARRAY_LEN; ++i)
            endianSwap64(retValPtr++);
    #endif
    return retVal;
}

/// Wrapper for hashing methods, up to caller to free the return value
void SHA512Hash(uint64_t* result, const uint8_t *input, size_t len, size_t original_len)
{
    if (original_len == 0) {
      original_len = len;
    }
    struct PaddedMsg paddedMsg;
    preprocess(paddedMsg, input, len, original_len);
    getHash(result, &paddedMsg);
}
//#endregion


void test_1() {
  uint64_t result[HASH_RESULT_ARRAY_LEN];
  uint8_t input[] = {
35, 0, 73, 78, 71, 32, 84, 83, 32, 100, 108, 111, 103, 32, 112, 114, 111, 111, 102, 32, 115, 117, 98, 45, 112, 114, 111, 116, 111, 99, 111, 108, 32, 118, 49, 46, 48, 0, 1, 128, 41, 183, 15, 180, 168, 35, 128, 12, 7, 126, 172, 196, 163, 69, 192, 158, 254, 94, 226, 4, 43, 92, 248, 55, 14, 142, 166, 63, 54, 39, 200, 87, 106, 204, 74, 7, 124, 138, 24, 59, 97, 192, 78, 238, 48, 253, 106, 125, 251, 195, 219, 122, 255, 57, 79, 28, 244, 44, 3, 28, 147, 194, 22, 211, 122, 217, 116, 203, 59, 148, 226, 182, 83, 152, 106, 57, 245, 226, 144, 199, 137, 224, 217, 247, 243, 7, 62, 23, 73, 164, 147, 58, 46, 176, 74, 94, 62, 133, 54, 68, 188, 70, 2, 24, 84, 105, 208, 100, 177, 211, 141, 37, 60, 89, 143, 91, 161, 136, 136, 11, 64, 175, 27, 131, 143, 5, 60, 194, 157, 93, 245, 93, 240, 8, 237, 19, 94, 136, 149, 227, 137, 154, 182, 210, 62, 18, 52, 154, 202, 15, 209, 29, 215, 219, 211, 41, 106, 236, 111, 197, 231, 244, 251, 148, 16, 243, 40, 198, 145, 34, 50, 195, 204, 148, 89, 100, 129, 162, 200, 103, 211, 241, 35, 102, 185, 51, 172, 6, 185, 117, 61, 129, 1, 23, 79, 213, 133, 245, 12, 45, 245, 74, 180, 4, 145, 214, 4, 113, 247, 252, 221, 180, 58, 197, 141, 153, 129, 120, 24, 60, 250, 25, 41, 191, 98, 22, 235, 228, 62, 25, 201, 109, 33, 166, 19, 200, 143, 47, 212, 96, 45, 219, 88, 251, 236, 70, 0, 108, 70, 79, 150, 148, 35, 118, 49, 0, 1, 109, 1, 76, 84, 226, 80, 226, 25, 254, 105, 223, 19, 49, 219, 114, 138, 3, 20, 53, 246, 36, 154, 67, 144, 175, 40, 25, 6, 239, 2, 15, 163, 197, 36, 61, 182, 160, 60, 184, 188, 195, 41, 40, 60, 104, 148, 167, 125, 56, 107, 151, 134, 181, 107, 212, 214, 232, 98, 193, 55, 112, 12, 166, 103, 110, 20, 27, 155, 113, 250, 9, 16, 252, 112, 169, 222, 86, 28, 115, 247, 78, 245, 142, 6, 199, 57, 41, 111, 153, 157, 54, 204, 139, 231, 214, 122, 113, 94, 62, 67, 37, 51, 77, 115, 96, 81, 79, 177, 43, 87, 120, 220, 185, 135, 232, 197, 58, 236, 89, 133, 181, 208, 48, 224, 8, 90, 138, 185, 30, 112, 187, 239, 108, 59, 163, 8, 225, 70, 228, 11, 25, 186, 237, 131, 185, 105, 228, 233, 91, 98, 110, 70, 255, 229, 237, 83, 99, 129, 251, 191, 87, 181, 27, 236, 48, 130, 226, 156, 110, 241, 141, 231, 168, 152, 106, 71, 151, 76, 83, 147, 189, 131, 250, 69, 214, 104, 202, 140, 205, 191, 86, 226, 124, 239, 49, 103, 212, 223, 160, 142, 149, 175, 246, 15, 250, 112, 126, 158, 95, 227, 189, 91, 249, 206, 187, 29, 134, 157, 123, 41, 115, 255, 43, 109, 227, 254, 239, 223, 212, 136, 52, 96, 123, 32, 11, 147, 219, 176, 175, 170, 1, 130, 140, 32, 12, 197, 151, 237, 127, 248, 21, 169, 136, 246, 149, 106, 1, 0, 3, 0, 1, 70, 176, 118, 223, 61, 162, 95, 77, 227, 46, 159, 224, 12, 75, 204, 28, 203, 63, 228, 30, 101, 120, 16, 193, 159, 91, 45, 200, 78, 153, 223, 90, 160, 151, 32, 143, 209, 189, 22, 5, 210, 183, 248, 23, 93, 91, 251, 162, 173, 75, 62, 221, 42, 69, 11, 230, 127, 63, 235, 160, 22, 254, 111, 8, 163, 70, 159, 232, 191, 118, 241, 109, 136, 170, 204, 198, 142, 105, 150, 196, 93, 204, 232, 96, 101, 197, 109, 210, 158, 68, 91, 63, 47, 90, 34, 218, 151, 157, 176, 92, 230, 33, 92, 85, 240, 75, 27, 114, 184, 162, 195, 123, 226, 31, 7, 48, 249, 129, 251, 129, 10, 239, 52, 105, 17, 241, 149, 177, 214, 23, 119, 227, 136, 210, 215, 64, 125, 23, 154, 245, 134, 29, 147, 29, 135, 193, 138, 82, 220, 147, 43, 50, 196, 2, 16, 83, 215, 176, 26, 94, 123, 79, 105, 205, 105, 102, 193, 131, 191, 178, 101, 81, 114, 48, 22, 35, 252, 225, 181, 42, 104, 228, 12, 138, 181, 199, 248, 78, 91, 203, 26, 44, 116, 203, 101, 151, 211, 146, 247, 147, 101, 37, 76, 199, 230, 45, 207, 210, 59, 187, 62, 88, 132, 246, 166, 61, 96, 213, 129, 75, 226, 9, 79, 246, 45, 56, 161, 199, 181, 28, 105, 142, 151, 28, 214, 148, 1, 243, 175, 85, 68, 43, 237, 174, 46, 120, 59, 199, 167, 91, 161, 207, 114, 156, 211, 218
  };

  SHA512Hash(result, input + 128*4, 814 - 128*4, 814);
  SHA512Hash(result, input, 814, 0);
}

void test_2() {
  uint64_t result[HASH_RESULT_ARRAY_LEN];
  uint8_t input[] = {
35, 0, 73, 78, 71, 32, 84, 83, 32, 100, 108, 111, 103, 32, 112, 114, 111, 111, 102, 32, 115, 117, 98, 45, 112, 114, 111, 116, 111, 99, 111, 108, 32, 118, 49, 46, 48, 0, 1, 128, 41, 183, 15, 180, 168, 35, 128, 12, 7, 126, 172, 196, 163, 69, 192, 158, 254, 94, 226, 4, 43, 92, 248, 55, 14, 142, 166, 63, 54, 39, 200, 87, 106, 204, 74, 7, 124, 138, 24, 59, 97, 192, 78, 238, 48, 253, 106, 125, 251, 195, 219, 122, 255, 57, 79, 28, 244, 44, 3, 28, 147, 194, 22, 211, 122, 217, 116, 203, 59, 148, 226, 182, 83, 152, 106, 57, 245, 226, 144, 199, 137, 224, 217, 247, 243, 7, 62, 23, 73, 164, 147, 58, 46, 176, 74, 94, 62, 133, 54, 68, 188, 70, 2, 24, 84, 105, 208, 100, 177, 211, 141, 37, 60, 89, 143, 91, 161, 136, 136, 11, 64, 175, 27, 131, 143, 5, 60, 194, 157, 93, 245, 93, 240, 8, 237, 19, 94, 136, 149, 227, 137, 154, 182, 210, 62, 18, 52, 154, 202, 15, 209, 29, 215, 219, 211, 41, 106, 236, 111, 197, 231, 244, 251, 148, 16, 243, 40, 198, 145, 34, 50, 195, 204, 148, 89, 100, 129, 162, 200, 103, 211, 241, 35, 102, 185, 51, 172, 6, 185, 117, 61, 129, 1, 23, 79, 213, 133, 245, 12, 45, 245, 74, 180, 4, 145, 214, 4, 113, 247, 252, 221, 180, 58, 197, 141, 153, 129, 120, 24, 60, 250, 25, 41, 191, 98, 22, 235, 228, 62, 25, 201, 109, 33, 166, 19, 200, 143, 47, 212, 96, 45, 219, 88, 251, 236, 70, 0, 108, 70, 79, 150, 148, 35, 118, 49, 0, 1, 109, 1, 76, 84, 226, 80, 226, 25, 254, 105, 223, 19, 49, 219, 114, 138, 3, 20, 53, 246, 36, 154, 67, 144, 175, 40, 25, 6, 239, 2, 15, 163, 197, 36, 61, 182, 160, 60, 184, 188, 195, 41, 40, 60, 104, 148, 167, 125, 56, 107, 151, 134, 181, 107, 212, 214, 232, 98, 193, 55, 112, 12, 166, 103, 110, 20, 27, 155, 113, 250, 9, 16, 252, 112, 169, 222, 86, 28, 115, 247, 78, 245, 142, 6, 199, 57, 41, 111, 153, 157, 54, 204, 139, 231, 214, 122, 113, 94, 62, 67, 37, 51, 77, 115, 96, 81, 79, 177, 43, 87, 120, 220, 185, 135, 232, 197, 58, 236, 89, 133, 181, 208, 48, 224, 8, 90, 138, 185, 30, 112, 187, 239, 108, 59, 163, 8, 225, 70, 228, 11, 25, 186, 237, 131, 185, 105, 228, 233, 91, 98, 110, 70, 255, 229, 237, 83, 99, 129, 251, 191, 87, 181, 27, 236, 48, 130, 226, 156, 110, 241, 141, 231, 168, 152, 106, 71, 151, 76, 83, 147, 189, 131, 250, 69, 214, 104, 202, 140, 205, 191, 86, 226, 124, 239, 49, 103, 212, 223, 160, 142, 149, 175, 246, 15, 250, 112, 126, 158, 95, 227, 189, 91, 249, 206, 187, 29, 134, 157, 123, 41, 115, 255, 43, 109, 227, 254, 239, 223, 212, 136, 52, 96, 123, 32, 11, 147, 219, 176, 175, 170, 1, 130, 140, 32, 12, 197, 151, 237, 127, 248, 21, 169, 136, 246, 149, 106, 1, 0, 3, 0, 1, 109, 1, 76, 84, 226, 80, 226, 25, 254, 105, 223, 19, 49, 219, 114, 138, 3, 20, 53, 246, 36, 154, 67, 144, 175, 40, 25, 6, 239, 2, 15, 163, 197, 36, 61, 182, 160, 60, 184, 188, 195, 41, 40, 60, 104, 148, 167, 125, 56, 107, 151, 134, 181, 107, 212, 214, 232, 98, 193, 55, 112, 12, 166, 103, 110, 20, 27, 155, 113, 250, 9, 16, 252, 112, 169, 222, 86, 28, 115, 247, 78, 245, 142, 6, 199, 57, 41, 111, 153, 157, 54, 204, 139, 231, 214, 122, 113, 94, 62, 67, 37, 51, 77, 115, 96, 81, 79, 177, 43, 87, 120, 220, 185, 135, 232, 197, 58, 236, 89, 133, 181, 208, 48, 224, 8, 90, 138, 185, 30, 112, 187, 239, 108, 59, 163, 8, 225, 70, 228, 11, 25, 186, 237, 131, 185, 105, 228, 233, 91, 98, 110, 70, 255, 229, 237, 83, 99, 129, 251, 191, 87, 181, 27, 236, 48, 130, 226, 156, 110, 241, 141, 231, 168, 152, 106, 71, 151, 76, 83, 147, 189, 131, 250, 69, 214, 104, 202, 140, 205, 191, 86, 226, 124, 239, 49, 103, 212, 223, 160, 142, 149, 175, 246, 15, 250, 112, 126, 158, 95, 227, 189, 91, 249, 206, 187, 29, 134, 157, 123, 41, 115, 255, 43, 109, 227, 254, 239, 223, 212, 136, 52, 96, 123, 32, 11, 147, 219, 176, 175, 170, 1, 130, 140, 32, 12, 197, 151, 237, 127, 248, 21, 169, 136, 246, 149, 106
  };
  SHA512Hash(result, input, 814, 0);
}

void test_3() {
  uint64_t result[HASH_RESULT_ARRAY_LEN];
  uint8_t input[] = {
35, 0, 73, 78, 71, 32, 84, 83, 32, 100, 108, 111, 103, 32, 112, 114, 111, 111, 102, 32, 115, 117, 98, 45, 112, 114, 111, 116, 111, 99, 111, 108, 32, 118, 49, 46, 48, 0, 1, 128, 41, 183, 15, 180, 168, 35, 128, 12, 7, 126, 172, 196, 163, 69, 192, 158, 254, 94, 226, 4, 43, 92, 248, 55, 14, 142, 166, 63, 54, 39, 200, 87, 106, 204, 74, 7, 124, 138, 24, 59, 97, 192, 78, 238, 48, 253, 106, 125, 251, 195, 219, 122, 255, 57, 79, 28, 244, 44, 3, 28, 147, 194, 22, 211, 122, 217, 116, 203, 59, 148, 226, 182, 83, 152, 106, 57, 245, 226, 144, 199, 137, 224, 217, 247, 243, 7, 62, 23, 73, 164, 147, 58, 46, 176, 74, 94, 62, 133, 54, 68, 188, 70, 2, 24, 84, 105, 208, 100, 177, 211, 141, 37, 60, 89, 143, 91, 161, 136, 136, 11, 64, 175, 27, 131, 143, 5, 60, 194, 157, 93, 245, 93, 240, 8, 237, 19, 94, 136, 149, 227, 137, 154, 182, 210, 62, 18, 52, 154, 202, 15, 209, 29, 215, 219, 211, 41, 106, 236, 111, 197, 231, 244, 251, 148, 16, 243, 40, 198, 145, 34, 50, 195, 204, 148, 89, 100, 129, 162, 200, 103, 211, 241, 35, 102, 185, 51, 172, 6, 185, 117, 61, 129, 1, 23, 79, 213, 133, 245, 12, 45, 245, 74, 180, 4, 145, 214, 4, 113, 247, 252, 221, 180, 58, 197, 141, 153, 129, 120, 24, 60, 250, 25, 41, 191, 98, 22, 235, 228, 62, 25, 201, 109, 33, 166, 19, 200, 143, 47, 212, 96, 45, 219, 88, 251, 236, 70, 0, 108, 70, 79, 150, 148, 35, 118, 49, 0, 1, 109, 1, 76, 84, 226, 80, 226, 25, 254, 105, 223, 19, 49, 219, 114, 138, 3, 20, 53, 246, 36, 154, 67, 144, 175, 40, 25, 6, 239, 2, 15, 163, 197, 36, 61, 182, 160, 60, 184, 188, 195, 41, 40, 60, 104, 148, 167, 125, 56, 107, 151, 134, 181, 107, 212, 214, 232, 98, 193, 55, 112, 12, 166, 103, 110, 20, 27, 155, 113, 250, 9, 16, 252, 112, 169, 222, 86, 28, 115, 247, 78, 245, 142, 6, 199, 57, 41, 111, 153, 157, 54, 204, 139, 231, 214, 122, 113, 94, 62, 67, 37, 51, 77, 115, 96, 81, 79, 177, 43, 87, 120, 220, 185, 135, 232, 197, 58, 236, 89, 133, 181, 208, 48, 224, 8, 90, 138, 185, 30, 112, 187, 239, 108, 59, 163, 8, 225, 70, 228, 11, 25, 186, 237, 131, 185, 105, 228, 233, 91, 98, 110, 70, 255, 229, 237, 83, 99, 129, 251, 191, 87, 181, 27, 236, 48, 130, 226, 156, 110, 241, 141, 231, 168, 152, 106, 71, 151, 76, 83, 147, 189, 131, 250, 69, 214, 104, 202, 140, 205, 191, 86, 226, 124, 239, 49, 103, 212, 223, 160, 142, 149, 175, 246, 15, 250, 112, 126, 158, 95, 227, 189, 91, 249, 206, 187, 29, 134, 157, 123, 41, 115, 255, 43, 109, 227, 254, 239, 223, 212, 136, 52, 96, 123, 32, 11, 147, 219, 176, 175, 170, 1, 130, 140, 32, 12, 197, 151, 237, 127, 248, 21, 169, 136, 246, 149, 106, 1, 0, 3, 1, 0, 1
  };
  SHA512Hash(result, input, 559, 0);
}


void test_4() {
  uint64_t result[HASH_RESULT_ARRAY_LEN];
  uint8_t input[] = {
29, 134, 157, 123, 41, 115, 255, 43, 109, 227, 254, 239, 223, 212, 136, 52, 96, 123, 32, 11, 147, 219, 176, 175, 170, 1, 130, 140, 32, 12, 197, 151, 237, 127, 248, 21, 169, 136, 246, 149, 106, 1, 0, 3, 1, 0, 1
  };
  uint8_t input_full[] = {
35, 0, 73, 78, 71, 32, 84, 83, 32, 100, 108, 111, 103, 32, 112, 114, 111, 111, 102, 32, 115, 117, 98, 45, 112, 114, 111, 116, 111, 99, 111, 108, 32, 118, 49, 46, 48, 0, 1, 128, 41, 183, 15, 180, 168, 35, 128, 12, 7, 126, 172, 196, 163, 69, 192, 158, 254, 94, 226, 4, 43, 92, 248, 55, 14, 142, 166, 63, 54, 39, 200, 87, 106, 204, 74, 7, 124, 138, 24, 59, 97, 192, 78, 238, 48, 253, 106, 125, 251, 195, 219, 122, 255, 57, 79, 28, 244, 44, 3, 28, 147, 194, 22, 211, 122, 217, 116, 203, 59, 148, 226, 182, 83, 152, 106, 57, 245, 226, 144, 199, 137, 224, 217, 247, 243, 7, 62, 23, 73, 164, 147, 58, 46, 176, 74, 94, 62, 133, 54, 68, 188, 70, 2, 24, 84, 105, 208, 100, 177, 211, 141, 37, 60, 89, 143, 91, 161, 136, 136, 11, 64, 175, 27, 131, 143, 5, 60, 194, 157, 93, 245, 93, 240, 8, 237, 19, 94, 136, 149, 227, 137, 154, 182, 210, 62, 18, 52, 154, 202, 15, 209, 29, 215, 219, 211, 41, 106, 236, 111, 197, 231, 244, 251, 148, 16, 243, 40, 198, 145, 34, 50, 195, 204, 148, 89, 100, 129, 162, 200, 103, 211, 241, 35, 102, 185, 51, 172, 6, 185, 117, 61, 129, 1, 23, 79, 213, 133, 245, 12, 45, 245, 74, 180, 4, 145, 214, 4, 113, 247, 252, 221, 180, 58, 197, 141, 153, 129, 120, 24, 60, 250, 25, 41, 191, 98, 22, 235, 228, 62, 25, 201, 109, 33, 166, 19, 200, 143, 47, 212, 96, 45, 219, 88, 251, 236, 70, 0, 108, 70, 79, 150, 148, 35, 118, 49, 0, 1, 109, 1, 76, 84, 226, 80, 226, 25, 254, 105, 223, 19, 49, 219, 114, 138, 3, 20, 53, 246, 36, 154, 67, 144, 175, 40, 25, 6, 239, 2, 15, 163, 197, 36, 61, 182, 160, 60, 184, 188, 195, 41, 40, 60, 104, 148, 167, 125, 56, 107, 151, 134, 181, 107, 212, 214, 232, 98, 193, 55, 112, 12, 166, 103, 110, 20, 27, 155, 113, 250, 9, 16, 252, 112, 169, 222, 86, 28, 115, 247, 78, 245, 142, 6, 199, 57, 41, 111, 153, 157, 54, 204, 139, 231, 214, 122, 113, 94, 62, 67, 37, 51, 77, 115, 96, 81, 79, 177, 43, 87, 120, 220, 185, 135, 232, 197, 58, 236, 89, 133, 181, 208, 48, 224, 8, 90, 138, 185, 30, 112, 187, 239, 108, 59, 163, 8, 225, 70, 228, 11, 25, 186, 237, 131, 185, 105, 228, 233, 91, 98, 110, 70, 255, 229, 237, 83, 99, 129, 251, 191, 87, 181, 27, 236, 48, 130, 226, 156, 110, 241, 141, 231, 168, 152, 106, 71, 151, 76, 83, 147, 189, 131, 250, 69, 214, 104, 202, 140, 205, 191, 86, 226, 124, 239, 49, 103, 212, 223, 160, 142, 149, 175, 246, 15, 250, 112, 126, 158, 95, 227, 189, 91, 249, 206, 187, 29, 134, 157, 123, 41, 115, 255, 43, 109, 227, 254, 239, 223, 212, 136, 52, 96, 123, 32, 11, 147, 219, 176, 175, 170, 1, 130, 140, 32, 12, 197, 151, 237, 127, 248, 21, 169, 136, 246, 149, 106, 1, 0, 3, 1, 0, 1
  };

  SHA512Hash(result, input, 47, 559);
  for(int i=0; i<32; i++) {
    printf("%02x", ((uint8_t*)result)[i] & 0xff);
  }
  printf("\n");

  SHA512Hash(result, input_full, 559, 0);
  for(int i=0; i<32; i++) {
    printf("%02x", ((uint8_t*)result)[i]);
  }
  printf("\n");
}

int main() {
  // printf("test1\n");
  // test_1();

  // printf("test2\n");
  // test_2();

  // printf("test3\n");
  // test_3();

  printf("test4\n");
  test_4();
  return 0;
}
